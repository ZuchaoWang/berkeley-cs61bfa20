# Build Your Own World Design Document

**Partner**: no partner, all done by me.

## Classes and Data Structures

### Main.java

Entry point of whole game, calls `Engine`'s methods to start game.

### Engine.java

Have two methods: `interactWithInputString` and `interactWithKeyboard`. They can start the game in two different modes. Each creates an instance of InputSource, then delegate to interactWithInput.

`interactWithInput` does a few things:

- Create the `SharedState`
- Initialize `TERenderer`
- Delegate user interaction to `ViewController`.

### SharedState.java

Records all states that are shared among different views of the game. That includes:

- `world`: the tiles that represent the world, will be generated by WorldGen
- `worldWidth` and `worldHeight`: the size of the world, determined by Engine
- `hudHeight`: HUD region height, determined by Engine
- `avatarX` and `avatarY`: position of avatar, will be generated by WorldGen, after world is generated

### WorldGen.java

Generate the world map in a pseudo-random way. The generated world map is recorded in `SharedState.world`. The world map generation includes several steps:

- `generateFloor`: randomly generate the floor, the actual generation mechanics are delegated to `WorldFloorGen`; the floor tiles must be connected
- `generateWall`: deterministically generate the wall around the floor; the 8 neighbours of floor must be either floor or wall
- `generateLockedDoor`: randomly pick a suitable wall and convert it into locked door; the locked door must connect floor on the one end, and outside region on the other end
- `generateEncounter`: randomly pick some floor and convert them into encounters; the encounters must not be adjacent

After the world map is generated, we can call `generateAvatarPos` to randomly pick a floor as avatar's initial position. This position is recorded in in `SharedState.avatarX` and `SharedState.avatarY`. The initial avatar position should not be too near to the locked door.

### WorldFloorGen.java

Generate the floor of the world map. This is the basis of whole world map generation. The only public method it has is `generateWorld`, which returns a 2D boolean array. This array has the same width and height of world map. A true value means that this position is a floor tile.

The result ensures that the floor size of every room is 2-6 tiles, and the distance between every two rooms' floor are at least 2 tiles away. We try to make the rooms not aligned.

### WorldFloorGenTest.java

A randomized test for `WorldFloorGen.generateWorld`. This test goes for 100 rounds, each time generating a world with different size, using different seed. It only checks that the generated world are connected. To check connectivity, it uses UnionFind algorithm.

### Utils.lab6.UnionFind.java

UnionFind algorithm implemented in lab6.

### Utils.lab6.UnionFindTest.java

The test of UnionFind algorithm.

### WorldUtils.java

Provide some convenient methods:

- `canMoveTo`: check whether a move is possible; a move is possible it won't hit the wall or go outside the floor area; this is used in `GamePlayView`

- `countNeighbourTiles4` and `countNeighbourTiles8`: count the types of neighbour tiles, used in `WorldGen`

### View.ViewController.java

It keeps the current active view. The active view will receive and handle user interaction with `BaseView.interact` method. It returns only when user switches view, e.g. from `GamePlayView` to `EncounterView`. The return value is the type of next view, then a view of that type is created and becomes the new active view. This new active view will start receiving and handling user interaction.

If no input is possible, `null` will be returned, then the whole game freezes. This only happens if we starts game with `Engine.interactWithInputString`.

### View.ViewType.java

This game can have different types of views. Each view serves for a specific purpose. For example, `WelcomeView` shows up when user just starts the game; `GamePlayView` shows up when user is actually moving the avatar in the worla map. All view types are defined here.

### View.BaseView.java

## Algorithms

## Persistence
