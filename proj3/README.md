# Build Your Own World Design Document

**Partner**: no partner, all done by me.

## Classes and Data Structures

### Main.java

Entry point of whole game, calls `Engine`'s methods to start game.

### Engine.java

Have two methods: `interactWithInputString` and `interactWithKeyboard`. They can start the game in two different modes. Each creates an instance of InputSource, then delegate to interactWithInput.

`interactWithInput` does a few things:

- Create the `SharedState`
- Initialize `TERenderer`
- Delegate user interaction to `ViewController`.

### SharedState.java

Records all states that are shared among different views of the game. That includes:

- `world`: the tiles that represent the world, will be generated by WorldGen
- `worldWidth` and `worldHeight`: the size of the world, determined by Engine
- `hudHeight`: HUD region height, determined by Engine
- `avatarX` and `avatarY`: position of avatar, will be generated by WorldGen, after world is generated

### WorldGen.java

Generate the world map in a pseudo-random way. The generated world map is recorded in `SharedState.world`. The world map generation includes several steps:

- `generateFloor`: randomly generate the floor, the actual generation mechanics are delegated to `WorldFloorGen`; the floor tiles must be connected
- `generateWall`: deterministically generate the wall around the floor; the 8 neighbours of floor must be either floor or wall
- `generateLockedDoor`: randomly pick a suitable wall and convert it into locked door; the locked door must connect floor on the one end, and outside region on the other end
- `generateEncounter`: randomly pick some floor and convert them into encounters; the encounters must not be adjacent

After the world map is generated, we can call `generateAvatarPos` to randomly pick a floor as avatar's initial position. This position is recorded in in `SharedState.avatarX` and `SharedState.avatarY`. The initial avatar position should not be too near to the locked door.

### WorldFloorGen.java

Generate the floor of the world map. This is the basis of whole world map generation. The only public method it has is `generateWorld`, which returns a 2D boolean array. This array has the same width and height of world map. A true value means that this position is a floor tile.

The result ensures that the floor size of every room is 2-6 tiles, and the distance between every two rooms' floor are at least 2 tiles away. We try to make the rooms not aligned.

### WorldFloorGenTest.java

A randomized test for `WorldFloorGen.generateWorld`. This test goes for 100 rounds, each time generating a world with different size, using different seed. It only checks that the generated world are connected. To check connectivity, it uses UnionFind algorithm.

### Utils.lab6.UnionFind.java

UnionFind algorithm implemented in lab6.

### Utils.lab6.UnionFindTest.java

The test of UnionFind algorithm.

### WorldUtils.java

Provide some convenient methods:

- `canMoveTo`: check whether a move is possible; a move is possible it won't hit the wall or go outside the floor area; this is used in `GamePlayView`

- `countNeighbourTiles4` and `countNeighbourTiles8`: count the types of neighbour tiles, used in `WorldGen`

### View.ViewController.java

It keeps the current active view. The active view will receive and handle user interaction with `BaseView.interact` method. It returns only when user switches view, e.g. from `GamePlayView` to `EncounterView`. The return value is the type of next view, then a view of that type is created and becomes the new active view. This new active view will start receiving and handling user interaction.

If no input is possible, `null` will be returned, then the whole game freezes. This only happens if we starts game with `Engine.interactWithInputString`.

### View.ViewType.java

This game can have different types of views. Each view serves for a specific purpose. For example, `WelcomeView` shows up when user just starts the game; `GamePlayView` shows up when user is actually moving the avatar in the worla map; `ExitView` ends the game. All view types are defined here, and most of their switching relationship is shown below.

```text
                         ┌ ASDW ┐
                         │      ▾
──▸ Welcome ──── L ────▸ GamePlay ────▸ Encounter
     │  │                ▴ │  │ ▴           │ 
     Q  N                | :Q | |           B
     │  │                │ │  │ │           │ 
     │  └─── WorldGen ───┘ │  │ └──────────-┘
     ▾                     │  │ 
◂── Exit ◂────── Save ─────┘  │ 
     ▴                        │ 
     └────────── YouWin ──────┘

```

### View.BaseView.java

This the interface of all views. It has only one method `interact`. It accepts user interaction from `InputSource`, modify `SharedState`, and render the view with `TERenderer`.

### View.Impl.WelcomeView.java

When user first enter the game, they are presented with the `WelcomeView`. It asks user what to do next:

- Press L to load state from a previous run, then enter `GamePlayView`
- Press N to enter `WorldGenView`, which will make a new random world map
- Press Q to enter `ExitView`, which will end the game

The entry of this view is its `interact` method. It does the following jobs:

- Render the view via `render`
- Accepts one character from user input, convert it to lowercase and let `handleNextChar` to do what this character commands
- `handleNextChar` will return the next view type, if it changes, we return `interact` and switch to next view; otherwise we are still in this view, and we go back to previous step waiting for next character

Most views' `interact` method follows this paradigm, except for `SaveView` and `ExitView`.

### View.Impl.WorldGenView.java

After user presses N in `WelcomeView`, she will enter `WorldGenView`. Here user will enter a seed integer, then confirm via pressing S. Then `WorldGen.generateWorld` and `WorldGen.generateAvatarPos` will be called, to generate a new random world map and set up the initial position of avatar. Then it will switch to `GamePlayView`.

### View.Impl.GamePlayView.java

User can enter this view via three ways:

- Load state from `save.txt`, by pressing L in `WelcomeView`; this file is saved in previous run
- Generate a new random world map, by entering seed and pressing S in `WorldGenView`
- Leave encounter, by pressing B in `EncounterView`

In this view, user can press A/S/D/W to move the avatar to different direction by one step. The move can only happen when avatar won't hit the wall or escape from the floor area. If user move to an encounter tile, she will enter `EncounterView`. If user move to the only locked door tile, she wins and thus will enter `YouWinView`.

User can also press :Q to enter `SaveView`.

### View.Impl.EncounterView.java

User arrives at this view by moving to an encounter tile in `GamePlayView`. Then user can press B to go back to `GamePlayView`.

### View.Impl.YouWinView.java

User arrives at this view by moving to a locked door tile in `GamePlayView`. Entering this view means the user wins. Then user can confirm the victory by pressing Q. This will enter `ExitView`.

### View.Impl.SaveView.java

User arrives at this view by pressing :Q in `GamePlayView`. After entering this view, no interaction will be performed. This view will immediately save game state into a file `save.txt`, then switch to `ExitView`.

### View.Impl.ExitView.java

User can enter this view by pressing Q in `WelcomeView`, `YouWinView`. User can also switch to this view automatically if load failed in `WelcomeView`, or after entering `SaveView`. This view will do no interaction. It just call `System.exit` to end the game.

## Algorithms

### World Floor Generation Algorithm

The goal is to generate the floor of world map randomly. The final result is represented as a 2d boolean array, with true representing floor tile. We briefly follows the [Binary Space Partitioning algorithm](https://gamedev.stackexchange.com/questions/82059/algorithm-for-procedureral-2d-map-with-connected-paths), see `WorldFloorGen.generateWorld` for full implementation. To repeat the basic ideas, below are the steps of the algorithm:

- **Partition** the whole map space into rooms, using a BSP
- **Shrink** rooms and make them unaligned
- **Connect** the sibling nodes in the BSP to make hallways
- **Rasterize** the world map, that is, to determine for each tile whether its floor or not

#### Partition 

The parition phase is implemented in `WorldFloorGen.partitionWorld`. It is a recursive partition. We first make the whole world area into one room, represented by a BSP node. The BSP node has following fields:

- `roomLeft`, `roomRight`, `roomBottom` and `roomTop`: geometry of BSP node; for leaf node this is the room geometry, for non-leaf node this is the bounding box of children nodes' geometry
- `isLeaf`: whether this is a leaf node or not
- `hallwayPivotX` and `hallwayPivotY`: pivot position of hallway connection
- `leftChild` and `righChild`: children BSPNode; but both will be null if this is a leaf node

For every BSP node, we try to partition it into two subnodes, and the room will subsequently be broken into two rooms. The split direction is random: either along x direction or y direction.

During the partition, we ensure the two subnodes are separated by a distance of `minZoomInterMargin`. This gap is later used to build walls.

We also ensure the subnodes are not too small, i.e. its width and height must be at least `minZoomWidth + minZoomInnerMargin`. Thus, if for example in the x direction, the width is less than `2 * (minZoomWidth + minZoomInnerMargin) + minZoomInterMargin`, then it's impossible to make the split. In such case we don't split in x-direction. If the subnodes are very large, i.e. its width are at least `2 * (maxZoomWidth + minZoomInnerMargin) + minZoomInterMargin`, then we must allow split in x-direction. If the size is in between, we have a 50% change to allow split.

Eventually, if both x/y direction allows split, we choose one direction randomly. If only one direction allows split, we split in that direction. If no direction allows split, the recursive split ends.

If eventually we choose to partition in x direction, we call `WorldFloorGen.partitionWorldAtX`. Otherwise if we choose to partition in y direction, we call `WorldFloorGen.partitionWorldAtY`. These two methods will recursives call `WorldFloorGen.partitionWorld` on the partitioned subnodes.

In the end, we have a BSP tree, where each leaf node contains a room. Each non-leaf node will have exactly two leaf nodes, either paritioned at x direction or at y direction.

#### Shrink

The shrink phase is implemented in `WorldFloorGen.shrinkRooms`. We first remove `minZoomInnerMargin` columns (x-direction removal) and `minZoomInnerMargin` rows (y-direction removal). The x-direction removal must be either all on the left, or all on the right. The y-direction removal must be either all on the bottom, or all on the top. Whether left or right, bottom or top, are random. This is mainly to make the nodes unaligned.

Then we continue to shrink the nodes. We will make sure their width and height are at least minRoomWidth, and at most maxRoomWidth.

Until now we have determined the geometry of all leaf nodes. Finally we update the bounding box of all non-leaf BSP nodes.

#### Connect

We try to connect sibling nodes in the BSP tree. To do that, we will pick a pivot node for every non-leaf node, the connecting hallway can be uniquely determined by the position of pivot. We have two conditions. 

**Condition 1**: If the two sibling's bounding box can see each other, we put the pivot between them. In the figure below, assuming L region is the bounding box of left child, R region is the bounding box of right child, then we will put pivot point randomly in one of the p position. Later by extending the pivot to left and to right, we can connect the left child and right child. This creates a straight line connection.

```text
LLL
LLL  p  RRRR
LLL  p  RRRR
        RRRR
```

**Condition 2**: If the two sibling's bounding box cannot see each other, we put the pivot at the corner. In the figure below, we can put the pivot randomly in one of the p position. Assuming p is eventually chosen to be somewhere top right, later we can extend pivot leftward and downward to connect the chidlren. This creates a z-shape connection.

```text
LLL  pppp
LLL  pppp
LLL  pppp

ppp  RRRR
ppp  RRRR
ppp  RRRR
```

#### Rasterize

The rasterization phase consists of three methods. We first create an empty world using `WorldFloorGen.rasterizeInit`. This is a 2d boolean array filled with false.

Then `WorldFloorGen.rasterizeRoom` visits all leaf nodes of the BSP tree, converting corresponding region into true value.

Finally `WorldFloorGen.rasterizeHallway` visits all non-leaf nodes of the BSP tree, extending the pivot point towards both children until it connects to the children. Since the bounding box is tight, we are guaranteed to connect to the children. All tiles visited by the pivot turned into floor and are marked by true.

There are some subtlies when extending the pivot point. Consider the example below, where a child node is represented by + and F. F are the actual floor region, but its bounding box also contains + region. Notice the pivot is at p position, and we will extend it leftward to connect to the child node. 

```text
+++++FF++++++FF
FFFFFFFFFFFFFFF
FFF++++++FF++++
FFF++++++++++++  p
```

Definitely we must cannot stop outside the bounding box, at the right of the bottom right +. In that way, although p connects with the bounding box, it does not connects with the floor region F, as shown below. Here h means the hallway points extended from the pivot.

```text
+++++FF++++++FF
FFFFFFFFFFFFFFF
FFF++++++FF++++
FFF++++++++++++hhp
```

We also should not keep extending pivot until it hits the floor as shown below. Because that will create unpleasant holes.

```text
+++++FF++++++FF
FFFFFFFFFFFFFFF
FFF++++++FF++++
FFFhhhhhhhhhhhhhhp
```

What we should do is stop when we just touch the floor, as shown below.

```text
+++++FF++++++FF
FFFFFFFFFFFFFFF
FFF++++++FF++++
FFF+++++++hhhhhhhp
```

### Avatar Initial Position Generation Algorithm

We need the position to be random, to be in the floor region, and not too near to the locked door. To do that, we randomly choose three floor tiles, and use the one farthest to the locked door as the initial avatar position. Here we simply use Euclidean distance to find the farthest tile. This is implemented in `WorldGen.generateAvatarPos`. This method returns the position as a 2-element int array: the first element is x position, second is y position.

## Persistence

Actually we have considered two schemes for persistence. First one is to remember all user input such as `N1234SASW`. This is reasonable, but a little bit complex:

- We need to skip commands such as L and Q and :Q, because we don't want them to be replayed
- After loading we need to replay all commands

Therefore we use a much simpler scheme, we just remember avatar position and world tiles. In this way, both saving and loading are easy. We save state in a fixed file named `save.txt`. It contents look as follows:

```text
51
6
32 -16777216 -16777216 false null
nothing
32 -16777216 -16777216 false null
nothing
......
```

The first row `51` is `SharedState.avatarX`. Then the second row `6` is `SharedState.avatarY`. The following rows are all the tiles, where each tile comprises two rows. The first row of the first tile is `32 -16777216 -16777216 false null`, representing `character`, `textColor`, `backgroundColor`, `filepath==null`, `filepath==null?"null":filepath`. The second row of the first tile is `nothing`, representing `description`. We notice a few subtlties:

- `character` is stored as int instead of char, this is because space character is hard to decode in text file
- `filepath` is stored as `filepath==null` and `filepath==null?"null":filepath`, this is because null is hard to store in text file
- `description` is stored in a separate row, this is because it can contain space, so we cannot store it as one field