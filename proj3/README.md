# Build Your Own World Design Document

**Partner**: no partner, all done by me.

## Classes and Data Structures

### Main.java

Entry point of whole game, calls `Engine`'s methods to start game.

### Engine.java

Have two methods: `interactWithInputString` and `interactWithKeyboard`. They can start the game in two different modes. Each creates an instance of InputSource, then delegate to interactWithInput.

`interactWithInput` does a few things:

- Create the `SharedState`
- Initialize `TERenderer`
- Delegate user interaction to `ViewController`.

### SharedState.java

Records all states that are shared among different views of the game. That includes:

- `world`: the tiles that represent the world, will be generated by WorldGen
- `worldWidth` and `worldHeight`: the size of the world, determined by Engine
- `hudHeight`: HUD region height, determined by Engine
- `avatarX` and `avatarY`: position of avatar, will be generated by WorldGen, after world is generated

### WorldGen.java

Generate the world map in a pseudo-random way. The generated world map is recorded in `SharedState.world`. The world map generation includes several steps:

- `generateFloor`: randomly generate the floor, the actual generation mechanics are delegated to `WorldFloorGen`; the floor tiles must be connected
- `generateWall`: deterministically generate the wall around the floor; the 8 neighbours of floor must be either floor or wall
- `generateLockedDoor`: randomly pick a suitable wall and convert it into locked door; the locked door must connect floor on the one end, and outside region on the other end
- `generateEncounter`: randomly pick some floor and convert them into encounters; the encounters must not be adjacent

After the world map is generated, we can call `generateAvatarPos` to randomly pick a floor as avatar's initial position. This position is recorded in in `SharedState.avatarX` and `SharedState.avatarY`. The initial avatar position should not be too near to the locked door.

### WorldFloorGen.java

Generate the floor of the world map. This is the basis of whole world map generation. The only public method it has is `generateWorld`, which returns a 2D boolean array. This array has the same width and height of world map. A true value means that this position is a floor tile.

The result ensures that the floor size of every room is 2-6 tiles, and the distance between every two rooms' floor are at least 2 tiles away. We try to make the rooms not aligned.

### WorldFloorGenTest.java

A randomized test for `WorldFloorGen.generateWorld`. This test goes for 100 rounds, each time generating a world with different size, using different seed. It only checks that the generated world are connected. To check connectivity, it uses UnionFind algorithm.

### Utils.lab6.UnionFind.java

UnionFind algorithm implemented in lab6.

### Utils.lab6.UnionFindTest.java

The test of UnionFind algorithm.

### WorldUtils.java

Provide some convenient methods:

- `canMoveTo`: check whether a move is possible; a move is possible it won't hit the wall or go outside the floor area; this is used in `GamePlayView`

- `countNeighbourTiles4` and `countNeighbourTiles8`: count the types of neighbour tiles, used in `WorldGen`

### View.ViewController.java

It keeps the current active view. The active view will receive and handle user interaction with `BaseView.interact` method. It returns only when user switches view, e.g. from `GamePlayView` to `EncounterView`. The return value is the type of next view, then a view of that type is created and becomes the new active view. This new active view will start receiving and handling user interaction.

If no input is possible, `null` will be returned, then the whole game freezes. This only happens if we starts game with `Engine.interactWithInputString`.

### View.ViewType.java

This game can have different types of views. Each view serves for a specific purpose. For example, `WelcomeView` shows up when user just starts the game; `GamePlayView` shows up when user is actually moving the avatar in the worla map; `ExitView` ends the game. All view types are defined here, and most of their switching relationship is shown below.

```text
                         ┌ ASDW ┐
                         │      ▾
──▸ Welcome ──── L ────▸ GamePlay ────▸ Encounter
     │  │                ▴ │  │ ▴           │ 
     Q  N                | :Q | |           B
     │  │                │ │  │ │           │ 
     │  └─── WorldGen ───┘ │  │ └──────────-┘
     ▾                     │  │ 
◂── Exit ◂────── Save ─────┘  │ 
     ▴                        │ 
     └────────── YouWin ──────┘

```

### View.BaseView.java

This the interface of all views. It has only one method `interact`. It accepts user interaction from `InputSource`, modify `SharedState`, and render the view with `TERenderer`.

### View.Impl.WelcomeView.java

When user first enter the game, they are presented with the `WelcomeView`. It asks user what to do next:

- Press L to load state from a previous run, then enter `GamePlayView`
- Press N to enter `WorldGenView`, which will make a new random world map
- Press Q to enter `ExitView`, which will end the game

The entry of this view is its `interact` method. It does the following jobs:

- Render the view via `render`
- Accepts one character from user input, convert it to lowercase and let `handleNextChar` to do what this character commands
- `handleNextChar` will return the next view type, if it changes, we return `interact` and switch to next view; otherwise we are still in this view, and we go back to previous step waiting for next character

Most views' `interact` method follows this paradigm, except for `SaveView` and `ExitView`.

### View.Impl.WorldGenView.java

After user presses N in `WelcomeView`, she will enter `WorldGenView`. Here user will enter a seed integer, then confirm via pressing S. Then `WorldGen.generateWorld` and `WorldGen.generateAvatarPos` will be called, to generate a new random world map and set up the initial position of avatar. Then it will switch to `GamePlayView`.

### View.Impl.GamePlayView.java

User can enter this view via three ways:

- Load state from `save.txt`, by pressing L in `WelcomeView`; this file is saved in previous run
- Generate a new random world map, by entering seed and pressing S in `WorldGenView`
- Leave encounter, by pressing B in `EncounterView`

In this view, user can press A/S/D/W to move the avatar to different direction by one step. The move can only happen when avatar won't hit the wall or escape from the floor area. If user move to an encounter tile, she will enter `EncounterView`. If user move to the only locked door tile, she wins and thus will enter `YouWinView`.

User can also press :Q to enter `SaveView`.

### View.Impl.EncounterView.java

User arrives at this view by moving to an encounter tile in `GamePlayView`. Then user can press B to go back to `GamePlayView`.

### View.Impl.YouWinView.java

User arrives at this view by moving to a locked door tile in `GamePlayView`. Entering this view means the user wins. Then user can confirm the victory by pressing Q. This will enter `ExitView`.

### View.Impl.SaveView.java

User arrives at this view by pressing :Q in `GamePlayView`. After entering this view, no interaction will be performed. This view will immediately save game state into a file `save.txt`, then switch to `ExitView`.

### View.Impl.ExitView.java

User can enter this view by pressing Q in `WelcomeView`, `YouWinView`. User can also switch to this view automatically if load failed in `WelcomeView`, or after entering `SaveView`. This view will do no interaction. It just call `System.exit` to end the game.

## Algorithms

### World Floor Generation Algorithm

The goal is to generate the floor of world map randomly. We briefly follows the [Binary Space Partitioning algorithm](https://gamedev.stackexchange.com/questions/82059/algorithm-for-procedureral-2d-map-with-connected-paths), see `WorldFloorGen.generateWorld` for full implementation. To repeat the basic ideas, below are the steps of the algorithm:

- **Partition** the whole map space into rooms, using a BSP
- **Shrink** rooms and make them unaligned
- **Connect** the sibling nodes in the BSP to make hallways
- **Rasterize** the world map, that is, to determine for each tile whether its floor or not

#### Partition 

The parition phase is implemented in `WorldFloorGen.partitionWorld`. It is a recursive partition. We first make the whole world area into one room, represented by a BSP node. Then for every BSP node, we try to partition it into two subnodes, and the room will subsequently be broken into two rooms. The split direction is random: either along x direction or y direction.

During the partition, we ensure the two subnodes are separated by a distance of `minZoomInterMargin`. This gap is later used to build walls.

We also ensure the subnodes are not too small, i.e. its width and height must be at least `minZoomWidth + minZoomInnerMargin`. Thus, if for example in the x direction, the width is less than `2 * (minZoomWidth + minZoomInnerMargin) + minZoomInterMargin`, then it's impossible to make the split. In such case we don't split in x-direction. If the subnodes are very large, i.e. its width are at least `2 * (maxZoomWidth + minZoomInnerMargin) + minZoomInterMargin`, then we must allow split in x-direction. If the size is in between, we have a 50% change to allow split.

Eventually, if both x/y direction allows split, we choose one direction randomly. If only one direction allows split, we split in that direction. If no direction allows split, the recursive split ends.

If eventually we choose to partition in x direction, we call `worldFloorGen.partitionWorldAtX`. Otherwise if we choose to partition in y direction, we call `worldFloorGen.partitionWorldAtY`. These two methods will recursives call `WorldFloorGen.partitionWorld` on the partitioned subnodes.

#### Shrink

The shrink phase is implemented in `worldFloorGen.shrinkRooms`. We first remove `minZoomInnerMargin` in x direction and in y direction. The x-direction remove must be either all on the left, or all on the right. The y-direction remove must be either all on the bottom, or all on the top. Whether left or right, bottom or top, are random. This is mainly to make the nodes unaligned.

Then we con

#### Connect

#### Rasterize

### Avatar Initial Position Generation Algorithm

## Persistence
